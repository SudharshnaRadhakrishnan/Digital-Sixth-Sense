#include <stdio.h>
#include <inttypes.h>
#include "drivers/mss_ace/mss_ace.h"
#include "drivers/mss_gpio/mss_gpio.h"
#include "tfmini.h"
#include "motor_control.h"
#include "drivers/mss_i2c/mss_i2c.h"
#include "motor_control.h"
#include <stdlib.h>
#include <assert.h>
#include <math.h>

double logcalculator(int pow){
	return exp(pow) + 30;
}

int main()
{
	MSS_GPIO_init();
	//MSS_GPIO_config(MSS_GPIO_0, MSS_GPIO_OUTPUT_MODE);
	MSS_GPIO_config(MSS_GPIO_1, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);
    MSS_GPIO_enable_irq( MSS_GPIO_1);

	//MSS_GPIO_set_output(MSS_GPIO_0, 255);

	ACE_init();
    /* DAC initialization */
    ACE_configure_sdd(
    	SDD1_OUT,
    	SDD_16_BITS,
    	SDD_VOLTAGE_MODE | SDD_RETURN_TO_ZERO,
    	INDIVIDUAL_UPDATE
    );
    ACE_enable_sdd(SDD1_OUT);

    uint32_t normVal = 2000;
    uint32_t outSig = 65536;
    uint32_t sigSw = 0;
    uint32_t counter = 0;

    uint32_t measure_counter = 0;

    while(1) {
    	if(measure_counter == 20){
    	// FROM LIDAR/MOTOR CODE
    	int distance = measure();
    	/*if(distance == -1){
    		assert(0);
    	}*/
    	int assign_level = 5;
    	int power = 2;
    	int level = -1;
    	while(assign_level >= 0 && level == -1){
    		if(distance < logcalculator(power)){
    			level = assign_level;
    		}
    		assign_level--;
    		power++;
    	}
    	/*if(level == -1){
    		// fail
    		return 1;
    	}*/
    	// call the level to the motor control
    	MSS_I2C_init( &g_mss_i2c1, DRV2605_ADDR, MSS_I2C_PCLK_DIV_256 );
    	init();
    	selectLibrary(1);
    	// I2C trigger by sending 'go' command
    	// default, internal trigger when sending GO command
    	setMode(DRV2605_MODE_INTTRIG);
    	setWaveform(0, 69 - level);
    	setWaveform(1, 0);       // end waveform
    	go();
    	measure_counter = 0;
    	}

    	//__________________________________________________________________________________
    	if (counter == 5) {
    		if (sigSw == 0) {
    			outSig = 65536;
    			sigSw = 1;
    		}
    		else if (sigSw == 1) {
    			outSig = 0;
    			sigSw = 0;
    		}
    		ACE_set_sdd_value(SDD1_OUT, (uint32_t)(outSig>>4));
    		counter = 0;
        	/*if (normVal >= 6000) {
        		normVal = 2000;
        	}
        	else {
        		normVal++;
        	}*/
    	}
    	counter += 1;
    	measure_counter++;
    }
}

void GPIO1_IRQHandler( void ) {
	uint32_t gpioOut = 65536;
	uint32_t sw = 0;
	uint32_t count = 0;
	uint32_t max = 500;
	uint32_t count2 = 0;

	while (count2 < 3000000) {
		if (count == max) {
			if (sw == 0) {
				gpioOut = 65536;
				sw = 1;
			}
			else if (sw == 1) {
				gpioOut = 0;
				sw = 0;
			}
			ACE_set_sdd_value(SDD1_OUT, (uint32_t)(gpioOut>>4));
			count = 0;
		}
		count += 1;
		count2 += 1;
	}
	//uint32_t gpioOut = MSS_GPIO_get_outputs();
	//MSS_GPIO_set_output(MSS_GPIO_0, (~gpioOut));
	//gpioOut = MSS_GPIO_get_outputs();
	MSS_GPIO_clear_irq( MSS_GPIO_1 );
}
